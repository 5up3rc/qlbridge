syntax = "proto3";

package schema;

// protoc --go_out=. *.proto


//import "github.com/araddon/qlbridge/rel/sql.proto";
//import "github.com/araddon/qlbridge/expr/node.proto";

// Command defines a Schema Replication command/message such as
// Drop, Alter, Create-Schema, etc.  Used to replicate schema changes
// across servers.
message Command {
	enum Operation {
		Unknown = 0;
		AddUpdate = 1;
		Drop = 2;
	}
	Operation op = 1;
	string origin = 2;
	string schema = 3;
	string type = 4;  // [schema, table]
	uint64 index = 5;
	int64 ts  = 6;
	bytes msg  = 7;
}

// SchemaPb defines the fields that define schema attributes, and
// can be serialized.
message SchemaPb {
	// Name of schema lowercased
	string name = 1;
	// Tables is map of tables
	map<string, TablePb> tables = 2;
	// source configuration
	ConfigSource conf = 3;
}

// Partition describes a range of data (in a Table).
// left-key is contained in this partition
// right key is not contained in this partition, in the next partition.
// So any value >= left-key, and < right-key is contained herein.
message TablePartition {
	string      table = 1;
	repeated string      keys = 2;
	repeated Partition partitions = 3;
}

// Partition describes a range of data
// the left-key is contained in this partition
// the right key is not contained in this partition, in the next one
message Partition {
	string      id = 1;
	string      left = 2;
	string      right = 3;
}

// TablePb defines the fields that define table attributes, and
// can be serialized.
message TablePb {
	// Name of table lowercased
	string name = 1;
	// Name of table (not lowercased)
	string nameOriginal = 2;
	// some dbs are more hiearchical (table-column-family)
	string parent = 3;
	// Character set, default = utf8
	uint32 Charset = 4;
	// Partitions in this table, optional may be empty
	TablePartition partition = 5;
	// Partition Count
	uint32 PartitionCt = 6;
	// List of indexes for this table
	repeated Index indexes = 7;
	// context is additional arbitrary map values
	map<string, string> context = 8;
	// List of Fields, in order
	repeated FieldPb fieldpbs = 9;
}

// FieldPb defines attributes of a field/column that can
// be serialized and transported.
message FieldPb {
	string         name = 1;
	string          description = 2;
	string          key = 3;
	string          extra = 4;
	string          data = 5;
	uint32          length = 6;
	uint32          type = 7;
	uint32          nativeType = 8;
	uint64          defLength = 9;
	bytes           defVal = 11;
	bool            indexed = 13;
	bool            noNulls = 14;
	string          collation = 15;
	repeated string roles = 16;
	repeated Index  indexes = 17;
	// context is additional arbitrary map values
	map<string, string> context = 18;
	uint64          position = 19; // Positional index in list of fields for table
}

// Index a description of how field(s) should be indexed for a table.
message Index {
	string name = 1;
	repeated string fields = 2;
	bool primaryKey = 3;
	repeated string hashPartition = 4;
	int32 partitionSize = 5;
}

/*
// ConfigSchema is the config block for Schema, the data-sources
// that make up this Virtual Schema.  Must have a name and list
// of sources to include.
ConfigSchema struct {
	Name    string   `json:"name"`    // Virtual Schema Name, must be unique
	Sources []string `json:"sources"` // List of sources , the names of the "Db" in source
	//ConfigNode []string `json:"-"`       // List of backend Servers
}

// ConfigSource are backend datasources ie : storage/database/csvfiles
// Each represents a single source type/config.  May belong to more
// than one schema.
ConfigSource struct {
	Name         string            `json:"name"`            // Name
	Schema       string            `json:"schema"`          // Schema Name if different than Name, will join existing schema
	SourceType   string            `json:"type"`            // [mysql,elasticsearch,csv,etc] Name in DataSource Registry
	TablesToLoad []string          `json:"tables_to_load"`  // if non empty, only load these tables
	TableAliases map[string]string `json:"table_aliases"`   // convert underlying table names to friendly ones
	Nodes        []*ConfigNode     `json:"nodes"`           // List of nodes
	Hosts        []string          `json:"hosts"`           // List of hosts, replaces older "nodes"
	Settings     map[string]string `json:"settings"`        // Arbitrary settings specific to each source type
	Partitions   []*TablePartition `json:"partitions"`      // List of partitions per table (optional)
	PartitionCt  uint32            `json:"partition_count"` // Instead of array of per table partitions, raw partition count
}

// ConfigNode are Servers/Services, ie a running instance of said Source
// - each must represent a single source type
// - normal use is a server, describing partitions of servers
// - may have arbitrary config info in Settings.
ConfigNode struct {
	Name     string            `json:"name"`     
	Source   string            `json:"source"`   
	Address  string            `json:"address"`  
	Settings map[string]string `json:"settings"` 
}
*/
// ConfigSchema is the config block for Schema, the data-sources
// that make up this Virtual Schema.  Must have a name and list
// of sources to include.
message ConfigSchema {
	string name = 1;
	repeated string sources = 2;
}

// ConfigSource are backend datasources ie : storage/database/csvfiles
// Each represents a single source type/config.  May belong to more
// than one schema.
message ConfigSource {
	string name = 1;
	string schema = 2;
	string sourceType = 3;
	repeated string tables_To_Load = 4;
	map<string, string> tableAliases = 5;    // convert underlying table names to friendly ones
	repeated string hosts = 7;
	map<string, string> settings = 8;
	repeated TablePartition partitions = 9;
	uint32 partitionCt = 10;
}

// ConfigNode are Servers/Services, ie a running instance of said Source
// - each must represent a single source type
// - normal use is a server, describing partitions of servers
// - may have arbitrary config info in Settings.
message ConfigNode {
	string              name = 1;    // Name of this Node optional
	string              source = 2;  // Name of source this node belongs to
	string              address = 3; // host/ip
	map<string, string> context = 4; // Arbitrary settings
}

